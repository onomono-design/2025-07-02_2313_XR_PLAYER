<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360Â° Headless Viewer - Enhanced</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.10/dist/hls.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        #viewer-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        a-scene {
            width: 100%;
            height: 100%;
        }
        
        /* Hide A-Frame inspector button and VR button */
        .a-inspect-button,
        .a-enter-vr-button {
            display: none !important;
        }
        
        /* Loading overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.3s ease;
        }
        
        #loading-overlay.show {
            display: flex;
            opacity: 1;
        }
        
        #loading-overlay.hidden {
            display: none;
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: white;
            margin-top: 16px;
            font-size: 14px;
        }
        
        /* Error overlay */
        #error-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(139, 69, 19, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 101;
            flex-direction: column;
        }
        
        .error-icon {
            width: 40px;
            height: 40px;
            background: #ff4444;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            margin-bottom: 16px;
        }
        
        .error-text {
            color: white;
            font-size: 14px;
            text-align: center;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div style="text-align: center;">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading 360Â° Experience...</div>
        </div>
    </div>
    
    <div id="error-overlay">
        <div class="error-icon">!</div>
        <div class="error-text" id="error-message">
            Failed to load 360Â° video. Please check the video URL and try again.
        </div>
    </div>
    
    <div id="viewer-container">
        <a-scene
            id="scene"
            embedded
            vr-mode-ui="enabled: false"
            device-orientation-permission-ui="enabled: true">
            
            <a-assets>
                <video
                    id="video-asset"
                    crossorigin="anonymous"
                    playsinline
                    preload="auto"
                    muted>
                </video>
            </a-assets>
            
            <a-videosphere
                id="videosphere"
                src="#video-asset"
                rotation="0 0 0">
            </a-videosphere>
            
            <a-camera
                id="camera"
                look-controls="enabled: true; pointerLockEnabled: false; magicWindowTrackingEnabled: true; reverseMouseDrag: true; reverseTouchDrag: true"
                wasd-controls="enabled: false"
                position="0 0 0"
                fov="75">
            </a-camera>
        </a-scene>
    </div>

    <script>
        class HeadlessViewer360 {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.videosphere = null;
                this.video = null;
                this.hlsPlayer = null;
                this.isReady = false;
                this.isSceneReady = false;
                this.isVideoReady = false;
                this.isPlaying = false;
                this.isMuted = false;
                this.currentTime = 0;
                this.duration = 0;
                this.videoUrl = '';
                this.parentOrigin = '*';
                this.lastHeartbeat = 0;
                this.connectionHealth = true;
                this.pendingPlaybackState = null;
                this.initializationStartTime = performance.now();
                this.autoStart = false;
                this.orientationPermission = 'unknown';
                this.devicePerformance = 'unknown';
                this.networkQuality = 'unknown';
                this.currentFov = 75;
                this.preloadProgress = 0;
                this.isBuffering = false;
                this.lastTimeUpdate = 0;
                this.syncTolerance = 0.1;
                this.lastSyncTime = 0;
                this.syncAttempts = 0;
                this.maxSyncAttempts = 5;
                this.isInSyncGracePeriod = false;
                this.syncGracePeriodStart = 0;
                this.gracePeriodDuration = 2000;
                this.performanceMonitor = {
                    fps: 0,
                    frameCount: 0,
                    lastFrameTime: 0,
                    averageFps: 0,
                    frameDrops: 0
                };
                this.lastPauseTime = 0;
                this.lastPlayTime = 0;
                this.pauseGracePeriod = 3000; // 3 second grace period after pause
                
                this.init();
            }
            
            init() {
                console.log('ðŸŽ¯ Initializing headless 360Â° viewer');
                
                // Get URL parameters
                const params = new URLSearchParams(window.location.search);
                this.videoUrl = params.get('video') || '';
                this.parentOrigin = params.get('origin') || '*';
                this.autoStart = params.get('autoStart') === 'true';
                
                // Initialize A-Frame scene
                this.scene = document.querySelector('#scene');
                this.camera = document.querySelector('#camera');
                this.videosphere = document.querySelector('#videosphere');
                this.video = document.querySelector('#video-asset');
                
                this.setupEventListeners();
                this.setupMessageHandling();
                this.startPerformanceMonitoring();
                this.detectDeviceCapabilities();
                this.detectNetworkQuality();
                
                // Request device orientation permission if needed
                this.requestDeviceOrientationPermission();
                
                // Auto-preload if specified
                if (this.autoStart && this.videoUrl) {
                    this.loadVideo(this.videoUrl);
                }
                
                // Send ready message after initialization
                setTimeout(() => {
                    this.sendMessage('ready', {
                        mode: 'headless',
                        autoStart: this.autoStart,
                        orientationPermission: this.orientationPermission,
                        devicePerformance: this.devicePerformance,
                        networkQuality: this.networkQuality
                    });
                }, 100);
                
                // Expose debug method to parent window
                if (window.parent && window.parent !== window) {
                    window.parent.xrVideoDebug = () => this.getPlaybackDebugInfo();
                }
            }
            
            setupEventListeners() {
                // A-Frame scene events
                this.scene.addEventListener('loaded', () => {
                    console.log('ðŸŽ¯ A-Frame scene loaded');
                    this.isSceneReady = true;
                    this.checkReadyState();
                });
                
                // Video events
                this.video.addEventListener('loadedmetadata', () => {
                    console.log('ðŸŽ¯ Video metadata loaded');
                    this.duration = this.video.duration;
                    this.isVideoReady = true;
                    this.checkReadyState();
                    
                    // Apply any pending playback state
                    if (this.pendingPlaybackState) {
                        this.applyPlaybackState(this.pendingPlaybackState);
                        this.pendingPlaybackState = null;
                    }
                });
                
                this.video.addEventListener('canplaythrough', () => {
                    console.log('ðŸŽ¯ Video can play through');
                    this.sendMessage('preloaded', {
                        duration: this.duration,
                        readyState: this.video.readyState
                    });
                });
                
                this.video.addEventListener('timeupdate', () => {
                    this.currentTime = this.video.currentTime;
                    this.sendMessage('timeupdate', {
                        currentTime: this.currentTime,
                        duration: this.duration
                    });
                });
                
                this.video.addEventListener('play', () => {
                    this.isPlaying = true;
                    console.log('ðŸŽ¯ Video play event fired');
                    this.sendMessage('play');
                });
                
                this.video.addEventListener('pause', () => {
                    this.isPlaying = false;
                    console.log('ðŸŽ¯ Video pause event fired');
                    this.sendMessage('pause');
                });
                
                this.video.addEventListener('volumechange', () => {
                    this.isMuted = this.video.muted;
                    this.sendMessage('mutechange', {
                        muted: this.isMuted,
                        volume: this.video.volume
                    });
                });
                
                this.video.addEventListener('seeking', () => {
                    this.isBuffering = true;
                    this.sendMessage('buffering', { isBuffering: true });
                });
                
                this.video.addEventListener('seeked', () => {
                    this.isBuffering = false;
                    this.sendMessage('buffering', { isBuffering: false });
                });
                
                this.video.addEventListener('error', (e) => {
                    console.error('ðŸŽ¯ Video error:', e);
                    this.showError('Video playback error');
                    this.sendMessage('error', {
                        error: 'Video playback error',
                        code: this.video.error?.code,
                        message: this.video.error?.message
                    });
                });
                
                // Camera FOV changes
                this.camera.addEventListener('componentchanged', (e) => {
                    if (e.detail.name === 'camera') {
                        this.currentFov = this.camera.getAttribute('fov');
                        this.sendMessage('fovchange', {
                            fov: this.currentFov
                        });
                    }
                });
                
                // Window events
                window.addEventListener('beforeunload', () => {
                    this.cleanup();
                });
            }
            
            setupMessageHandling() {
                window.addEventListener('message', (event) => {
                    if (event.data.channel !== 'viewer-360-headless') return;
                    
                    console.log('ðŸŽ¯ Received command:', event.data.type, event.data);
                    
                    this.handleCommand(event.data.type, event.data);
                });
            }
            
            handleCommand(type, data) {
                try {
                    switch (type) {
                        case 'start':
                            this.start();
                            break;
                        case 'playback-state':
                            this.handlePlaybackState(data);
                            break;
                        case 'time-update':
                            this.handleTimeUpdate(data);
                            break;
                        case 'play':
                            this.play();
                            break;
                        case 'pause':
                            this.pause();
                            break;
                        case 'togglePlay':
                            this.togglePlay();
                            break;
                        case 'seek':
                            this.seek(data.value || data.time);
                            break;
                        case 'syncSeek':
                            this.syncSeek(data.time, data.tolerance);
                            break;
                        case 'smoothSeek':
                            this.smoothSeek(data.time, data.tolerance);
                            break;
                        case 'mute':
                            this.setMute(data.value);
                            break;
                        case 'toggleMute':
                            this.toggleMute();
                            break;
                        case 'setFov':
                            this.setFov(data.value);
                            break;
                        case 'recenter':
                            this.recenter();
                            break;
                        case 'preload':
                            this.preload();
                            break;
                        case 'setVideoSource':
                            this.setVideoSource(data.videoUrl);
                            break;
                        case 'switchChapter':
                            this.switchChapter(data.chapterNumber, data.videoUrl);
                            break;
                        case 'setOrientationPermission':
                            this.setOrientationPermission(data.value);
                            break;
                        case 'requestOrientationPermission':
                            this.requestDeviceOrientationPermission();
                            break;
                        case 'getConnectionHealth':
                            this.getConnectionHealth();
                            break;
                        case 'heartbeat':
                            this.handleHeartbeat(data.timestamp);
                            break;
                        case 'ping':
                            this.handlePing(data.timestamp);
                            break;
                        case 'getPlaybackDebugInfo':
                            this.sendMessage('playbackdebuginfo', this.getPlaybackDebugInfo());
                            break;
                        default:
                            console.warn('ðŸŽ¯ Unknown command:', type);
                            this.sendMessage('commanderror', {
                                command: type,
                                error: 'Unknown command type'
                            });
                    }
                    
                    // Send success response
                    this.sendMessage('commandresponse', {
                        command: type,
                        success: true
                    });
                    
                } catch (error) {
                    console.error('ðŸŽ¯ Command error:', type, error);
                    this.sendMessage('commanderror', {
                        command: type,
                        error: error.message || 'Command execution failed'
                    });
                }
            }
            
            sendMessage(type, data = {}) {
                const message = {
                    channel: 'viewer-360-headless',
                    type: type,
                    timestamp: performance.now(),
                    ...data
                };
                
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage(message, this.parentOrigin);
                }
            }
            
            start() {
                console.log('ðŸŽ¯ Starting viewer');
                this.sendMessage('started', {
                    orientationPermission: this.orientationPermission,
                    hasDeviceYaw: this.hasDeviceYaw(),
                    mode: 'headless',
                    devicePerformance: this.devicePerformance,
                    networkQuality: this.networkQuality
                });
            }
            
            handlePlaybackState(data) {
                console.log('ðŸŽ¯ Handling playback state:', data);
                
                // Store the playback state for when video is ready
                this.pendingPlaybackState = data;
                
                // If video is ready, apply the state immediately
                if (this.isVideoReady && this.video) {
                    this.applyPlaybackState(data);
                }
            }
            
            applyPlaybackState(data) {
                if (!this.video || !this.isVideoReady) return;
                
                console.log('ðŸŽ¯ Applying playback state:', data);
                
                const now = performance.now();
                
                // Sync the current time if provided
                if (typeof data.currentTime === 'number' && data.currentTime >= 0) {
                    const timeDiff = Math.abs(this.video.currentTime - data.currentTime);
                    if (timeDiff > 0.5) { // Only sync if difference is significant
                        this.video.currentTime = data.currentTime;
                    }
                }
                
                // Apply play/pause state with grace period protection
                if (data.isPlaying && this.video.paused) {
                    // Check if we recently paused - if so, don't auto-play
                    const timeSinceLastPause = now - this.lastPauseTime;
                    if (timeSinceLastPause < this.pauseGracePeriod) {
                        console.log('ðŸŽ¯ Ignoring auto-play request - recent pause detected', { timeSinceLastPause });
                        return;
                    }
                    
                    console.log('ðŸŽ¯ Auto-starting video playback');
                    this.lastPlayTime = now;
                    this.video.play().catch(e => {
                        console.warn('ðŸŽ¯ Auto-play failed:', e);
                        // This is expected in some browsers without user interaction
                    });
                } else if (!data.isPlaying && !this.video.paused) {
                    console.log('ðŸŽ¯ Auto-pausing video playback');
                    this.lastPauseTime = now;
                    this.video.pause();
                }
            }
            
            handleTimeUpdate(data) {
                if (!this.video || !this.isVideoReady) return;
                
                // Only sync time if video is playing - avoid interfering with pause state
                if (!this.video.paused && typeof data.currentTime === 'number' && data.currentTime >= 0) {
                    const timeDiff = Math.abs(this.video.currentTime - data.currentTime);
                    if (timeDiff > 0.2) { // Sync if drift is significant
                        console.log('ðŸŽ¯ Syncing video time:', { 
                            videoTime: this.video.currentTime, 
                            parentTime: data.currentTime,
                            drift: timeDiff
                        });
                        this.video.currentTime = data.currentTime;
                    }
                }
            }
            
            play() {
                if (this.video && this.isVideoReady) {
                    this.lastPlayTime = performance.now();
                    this.video.play().catch(e => {
                        console.error('ðŸŽ¯ Play failed:', e);
                        this.sendMessage('error', { error: 'Play failed: ' + e.message });
                    });
                }
            }
            
            pause() {
                if (this.video && this.isVideoReady) {
                    this.lastPauseTime = performance.now();
                    this.video.pause();
                }
            }
            
            togglePlay() {
                if (this.isPlaying) {
                    this.pause();
                } else {
                    this.play();
                }
            }
            
            seek(time) {
                if (this.video && this.isVideoReady && time >= 0 && time <= this.duration) {
                    this.video.currentTime = time;
                    this.currentTime = time;
                }
            }
            
            syncSeek(time, tolerance = 0.1) {
                if (!this.video || !this.isVideoReady) return;
                
                const currentTime = this.video.currentTime;
                const drift = Math.abs(time - currentTime);
                
                if (drift > tolerance) {
                    console.log('ðŸŽ¯ Sync seek:', { from: currentTime, to: time, drift });
                    this.startSyncGracePeriod();
                    this.video.currentTime = time;
                }
            }
            
            smoothSeek(time, tolerance = 0.1) {
                if (!this.video || !this.isVideoReady) return;
                
                const currentTime = this.video.currentTime;
                const drift = time - currentTime;
                
                if (Math.abs(drift) > tolerance) {
                    const maxStep = 0.2;
                    const step = Math.sign(drift) * Math.min(Math.abs(drift), maxStep);
                    this.video.currentTime = currentTime + step;
                    
                    // Continue smooth seeking if needed
                    if (Math.abs(drift) > maxStep) {
                        setTimeout(() => {
                            this.smoothSeek(time, tolerance);
                        }, 50);
                    }
                }
            }
            
            setMute(muted) {
                if (this.video) {
                    this.video.muted = muted;
                }
            }
            
            toggleMute() {
                if (this.video) {
                    this.video.muted = !this.video.muted;
                }
            }
            
            setFov(fov) {
                if (this.camera && fov >= 75 && fov <= 120) {
                    this.camera.setAttribute('fov', fov);
                    this.currentFov = fov;
                }
            }
            
            recenter() {
                console.log('ðŸŽ¯ Recenter called - resetting camera rotation');
                
                if (this.camera) {
                    // Reset camera rotation
                    this.camera.setAttribute('rotation', '0 0 0');
                    
                    // Also reset any accumulated rotation from look controls
                    const lookControls = this.camera.components['look-controls'];
                    if (lookControls) {
                        lookControls.pitchObject.rotation.x = 0;
                        lookControls.yawObject.rotation.y = 0;
                        console.log('ðŸŽ¯ Reset look controls rotation');
                    }
                    
                    // Send success message back to parent
                    this.sendMessage('recenter', { 
                        success: true, 
                        timestamp: performance.now(),
                        rotation: { x: 0, y: 0, z: 0 }
                    });
                    
                    console.log('ðŸŽ¯ Camera recentered successfully');
                } else {
                    console.error('ðŸŽ¯ Cannot recenter - camera not found');
                    this.sendMessage('recenter', { 
                        success: false, 
                        error: 'Camera not found',
                        timestamp: performance.now()
                    });
                }
            }
            
            preload() {
                if (this.video && this.videoUrl) {
                    this.video.load();
                }
            }
            
            setVideoSource(videoUrl) {
                console.log('ðŸŽ¯ setVideoSource called with:', videoUrl);
                
                // Clean up any existing HLS player
                if (this.hlsPlayer) {
                    console.log('ðŸŽ¯ Cleaning up existing HLS player');
                    this.hlsPlayer.destroy();
                    this.hlsPlayer = null;
                }
                
                // Reset video element
                if (this.video) {
                    this.video.pause();
                    this.video.removeAttribute('src');
                    this.video.load();
                }
                
                this.videoUrl = videoUrl;
                this.isVideoReady = false;
                
                // Clear any pending playback state since we're loading a new video
                this.pendingPlaybackState = null;
                
                if (videoUrl) {
                    this.loadVideo(videoUrl);
                } else {
                    console.warn('ðŸŽ¯ No video URL provided to setVideoSource');
                }
            }
            
            switchChapter(chapterNumber, videoUrl) {
                console.log('ðŸŽ¯ Switching to chapter:', chapterNumber, videoUrl);
                this.setVideoSource(videoUrl);
            }
            
            setOrientationPermission(value) {
                this.orientationPermission = value;
                console.log('ðŸŽ¯ Device orientation permission set to:', value);
            }
            
            loadVideo(url) {
                console.log('ðŸŽ¯ Loading video:', url);
                this.showLoading();
                
                // Validate URL
                if (!url || typeof url !== 'string') {
                    this.showError('Invalid video URL provided', { url });
                    return;
                }
                
                // Set loading timeout
                const loadingTimeout = setTimeout(() => {
                    console.error('ðŸŽ¯ Video loading timeout');
                    this.showError('Video loading timeout - please check your connection', { url });
                }, 30000); // 30 seconds timeout
                
                // Clear timeout when video loads
                const clearLoadingTimeout = () => {
                    clearTimeout(loadingTimeout);
                };
                
                try {
                    if (url.includes('.m3u8')) {
                        this.loadHLSVideo(url, clearLoadingTimeout);
                    } else {
                        this.loadDirectVideo(url, clearLoadingTimeout);
                    }
                } catch (error) {
                    clearLoadingTimeout();
                    console.error('ðŸŽ¯ Error loading video:', error);
                    this.showError('Failed to load video', { url, error: error.message });
                }
            }
            
            loadHLSVideo(url, clearLoadingTimeout) {
                console.log('ðŸŽ¯ Loading HLS video:', url);
                if (Hls.isSupported()) {
                    this.hlsPlayer = new Hls();
                    this.hlsPlayer.loadSource(url);
                    this.hlsPlayer.attachMedia(this.video);
                    
                    this.hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
                        console.log('ðŸŽ¯ HLS manifest parsed');
                        clearLoadingTimeout();
                        
                        // Ensure videosphere is updated with new source
                        if (this.videosphere) {
                            this.videosphere.setAttribute('src', '#video-asset');
                            console.log('ðŸŽ¯ Updated videosphere source for HLS');
                        }
                        
                        this.hideLoading();
                    });
                    
                    this.hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
                        console.error('ðŸŽ¯ HLS error:', data);
                        clearLoadingTimeout();
                        this.showError('HLS streaming error - video may not be available', { 
                            url, 
                            errorType: data.type, 
                            errorDetails: data.details 
                        });
                    });
                } else if (this.video.canPlayType('application/vnd.apple.mpegurl')) {
                    this.video.src = url;
                    
                    // Ensure videosphere is updated with new source
                    if (this.videosphere) {
                        this.videosphere.setAttribute('src', '#video-asset');
                        console.log('ðŸŽ¯ Updated videosphere source for native HLS');
                    }
                    
                    clearLoadingTimeout();
                    this.hideLoading();
                } else {
                    clearLoadingTimeout();
                    this.showError('HLS not supported on this device', { url });
                }
            }
            
            loadDirectVideo(url, clearLoadingTimeout) {
                console.log('ðŸŽ¯ Loading direct video:', url);
                
                // Add error handling for direct video loading
                this.video.onerror = (error) => {
                    console.error('ðŸŽ¯ Direct video loading error:', error);
                    clearLoadingTimeout();
                    this.showError('Failed to load video file', { url, error: error.message });
                };
                
                this.video.onloadedmetadata = () => {
                    console.log('ðŸŽ¯ Direct video metadata loaded');
                    clearLoadingTimeout();
                    
                    // Ensure videosphere is updated with new source
                    if (this.videosphere) {
                        this.videosphere.setAttribute('src', '#video-asset');
                        console.log('ðŸŽ¯ Updated videosphere source');
                    }
                    
                    this.hideLoading();
                };
                
                this.video.src = url;
                this.video.load();
            }
            
            startPerformanceMonitoring() {
                const monitorFrame = () => {
                    const now = performance.now();
                    this.performanceMonitor.frameCount++;
                    
                    if (this.performanceMonitor.lastFrameTime > 0) {
                        const frameTime = now - this.performanceMonitor.lastFrameTime;
                        this.performanceMonitor.fps = 1000 / frameTime;
                        
                        // Update average FPS
                        if (this.performanceMonitor.frameCount > 10) {
                            this.performanceMonitor.averageFps = 
                                (this.performanceMonitor.averageFps * 0.9) + 
                                (this.performanceMonitor.fps * 0.1);
                        }
                        
                        // Detect frame drops
                        if (this.performanceMonitor.fps < 25) {
                            this.performanceMonitor.frameDrops++;
                        }
                        
                        // Send FPS updates occasionally
                        if (this.performanceMonitor.frameCount % 60 === 0) {
                            this.sendMessage('fpsupdate', {
                                fps: this.performanceMonitor.averageFps,
                                frameDrops: this.performanceMonitor.frameDrops
                            });
                        }
                    }
                    
                    this.performanceMonitor.lastFrameTime = now;
                    
                    if (this.isReady) {
                        requestAnimationFrame(monitorFrame);
                    }
                };
                
                requestAnimationFrame(monitorFrame);
            }
            
            detectDeviceCapabilities() {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                if (gl) {
                    const renderer = gl.getParameter(gl.RENDERER);
                    const vendor = gl.getParameter(gl.VENDOR);
                    
                    // Simple performance categorization
                    if (renderer.includes('Mali') || renderer.includes('Adreno 3')) {
                        this.devicePerformance = 'low';
                    } else if (renderer.includes('Adreno 5') || renderer.includes('PowerVR')) {
                        this.devicePerformance = 'medium';
                    } else {
                        this.devicePerformance = 'high';
                    }
                } else {
                    this.devicePerformance = 'low';
                }
                
                this.sendMessage('devicebenchmark', {
                    category: this.devicePerformance,
                    userAgent: navigator.userAgent
                });
            }
            
            detectNetworkQuality() {
                if ('connection' in navigator) {
                    const connection = navigator.connection;
                    const effectiveType = connection.effectiveType;
                    
                    if (effectiveType === '4g') {
                        this.networkQuality = 'high';
                    } else if (effectiveType === '3g') {
                        this.networkQuality = 'medium';
                    } else {
                        this.networkQuality = 'low';
                    }
                } else {
                    this.networkQuality = 'unknown';
                }
                
                this.sendMessage('networkdetected', {
                    quality: this.networkQuality
                });
            }
            
            async requestDeviceOrientationPermission() {
                if (typeof DeviceOrientationEvent !== 'undefined' && 
                    typeof DeviceOrientationEvent.requestPermission === 'function') {
                    
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        this.orientationPermission = permission;
                        
                        this.sendMessage('orientationpermission', {
                            granted: permission === 'granted',
                            permission: permission
                        });
                    } catch (error) {
                        console.warn('ðŸŽ¯ Device orientation permission error:', error);
                        this.orientationPermission = 'denied';
                    }
                } else {
                    // Assume granted for non-iOS devices
                    this.orientationPermission = 'granted';
                }
            }
            
            hasDeviceYaw() {
                return 'DeviceOrientationEvent' in window;
            }
            
            startSyncGracePeriod() {
                this.isInSyncGracePeriod = true;
                this.syncGracePeriodStart = performance.now();
                
                setTimeout(() => {
                    this.isInSyncGracePeriod = false;
                }, this.gracePeriodDuration);
            }
            
            handleHeartbeat(timestamp) {
                this.lastHeartbeat = timestamp;
                this.connectionHealth = true;
                
                this.sendMessage('heartbeat-response', {
                    timestamp: performance.now(),
                    clientTimestamp: timestamp
                });
            }
            
            handlePing(timestamp) {
                console.log('ðŸŽ¯ Ping received, sending pong response');
                this.sendMessage('pong', {
                    timestamp: performance.now(),
                    clientTimestamp: timestamp,
                    isReady: this.isReady,
                    isSceneReady: this.isSceneReady,
                    isVideoReady: this.isVideoReady,
                    connectionHealth: this.connectionHealth
                });
            }
            
            getConnectionHealth() {
                const now = performance.now();
                const timeSinceLastHeartbeat = now - this.lastHeartbeat;
                const isHealthy = timeSinceLastHeartbeat < 10000; // 10 seconds
                
                this.sendMessage('connectionhealthresponse', {
                    healthy: isHealthy,
                    lastHeartbeat: this.lastHeartbeat,
                    timeSinceLastHeartbeat: timeSinceLastHeartbeat,
                    performanceMonitor: this.performanceMonitor
                });
            }
            
            getPlaybackDebugInfo() {
                const now = performance.now();
                return {
                    isPlaying: this.isPlaying,
                    videoPaused: this.video ? this.video.paused : 'no video',
                    videoCurrentTime: this.video ? this.video.currentTime : 'no video',
                    lastPauseTime: this.lastPauseTime,
                    lastPlayTime: this.lastPlayTime,
                    timeSinceLastPause: now - this.lastPauseTime,
                    timeSinceLastPlay: now - this.lastPlayTime,
                    pauseGracePeriod: this.pauseGracePeriod,
                    isInGracePeriod: (now - this.lastPauseTime) < this.pauseGracePeriod
                };
            }
            
            checkReadyState() {
                if (this.isSceneReady && !this.isReady) {
                    this.isReady = true;
                    console.log('ðŸŽ¯ Viewer ready');
                    this.hideLoading();
                    
                    // Start performance monitoring
                    this.startPerformanceMonitoring();
                }
            }
            
            showLoading() {
                const overlay = document.getElementById('loading-overlay');
                if (overlay) {
                    overlay.classList.add('show');
                    overlay.classList.remove('hidden');
                }
            }
            
            hideLoading() {
                const overlay = document.getElementById('loading-overlay');
                if (overlay) {
                    overlay.classList.remove('show');
                    overlay.classList.add('hidden');
                }
            }
            
            showError(message, details = null) {
                const overlay = document.getElementById('error-overlay');
                const messageEl = document.getElementById('error-message');
                
                if (overlay && messageEl) {
                    messageEl.textContent = message;
                    overlay.style.display = 'flex';
                }
                
                this.hideLoading();
                
                // Send error to parent for handling
                this.sendMessage('error', {
                    error: message,
                    details: details,
                    timestamp: performance.now(),
                    recoverable: true
                });
                
                // Auto-hide error after 5 seconds for non-critical errors
                if (!message.includes('failed') && !message.includes('error')) {
                    setTimeout(() => {
                        this.hideError();
                    }, 5000);
                }
            }
            
            hideError() {
                const overlay = document.getElementById('error-overlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
            }
            
            cleanup() {
                if (this.hlsPlayer) {
                    this.hlsPlayer.destroy();
                }
                
                if (this.video) {
                    this.video.pause();
                    this.video.src = '';
                    this.video.load();
                }
                
                this.sendMessage('cleanup-complete');
            }
        }
        
        // Initialize the viewer when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            new HeadlessViewer360();
        });
    </script>
</body>
</html> 
</html> 