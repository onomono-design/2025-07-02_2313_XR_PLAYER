<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360Â° Headless Viewer - Enhanced</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.10/dist/hls.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        #viewer-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        a-scene {
            width: 100%;
            height: 100%;
        }
        
        /* Hide A-Frame inspector button and VR button */
        .a-inspect-button,
        .a-enter-vr-button {
            display: none !important;
        }
        
        /* Loading overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.3s ease;
        }
        
        #loading-overlay.show {
            display: flex;
            opacity: 1;
        }
        
        #loading-overlay.hidden {
            display: none;
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: white;
            margin-top: 16px;
            font-size: 14px;
        }
        
        /* Error overlay */
        #error-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(139, 69, 19, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 101;
            flex-direction: column;
        }
        
        .error-icon {
            width: 40px;
            height: 40px;
            background: #ff4444;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            margin-bottom: 16px;
        }
        
        .error-text {
            color: white;
            font-size: 14px;
            text-align: center;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div style="text-align: center;">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading 360Â° Experience...</div>
        </div>
    </div>
    
    <div id="error-overlay">
        <div class="error-icon">!</div>
        <div class="error-text" id="error-message">
            Failed to load 360Â° video. Please check the video URL and try again.
        </div>
    </div>
    
    <div id="viewer-container">
        <a-scene
            id="scene"
            embedded
            vr-mode-ui="enabled: false"
            device-orientation-permission-ui="enabled: true"
            renderer="colorManagement: true; outputColorSpace: srgb; antialias: true"
            background="color: #000000">
            
            <a-assets>
                <video
                    id="video-asset"
                    crossorigin="anonymous"
                    playsinline
                    preload="metadata"
                    muted
                    webkit-playsinline="true">
                </video>
            </a-assets>
            
            <a-videosphere
                id="videosphere"
                src="#video-asset"
                rotation="0 90 0"
                scale="1 1 1"
                geometry="phiStart: 0; phiLength: 360; thetaStart: 0; thetaLength: 180"
                mobile-video-fix>
            </a-videosphere>
            
            <a-camera
                id="camera"
                look-controls="enabled: true; pointerLockEnabled: false; magicWindowTrackingEnabled: true; reverseMouseDrag: false; reverseTouchDrag: true"
                wasd-controls="enabled: false"
                position="0 0 0"
                rotation="0 -90 0"
                fov="75">
            </a-camera>
        </a-scene>
    </div>

    <script>
        // Enhanced cross-platform color correction component
        AFRAME.registerComponent('mobile-video-fix', {
            init: function() {
                console.log('ðŸŽ¯ Initializing cross-platform video color fix');
                
                const videoEl = document.querySelector('#video-asset');
                const videosphere = this.el;
                
                if (videoEl && videosphere) {
                    // Apply fix when video loads or when mesh is ready
                    const applyColorFix = () => {
                        console.log('ðŸŽ¯ Applying cross-platform color fix');
                        
                        // Get the mesh and material
                        const mesh = videosphere.getObject3D('mesh');
                        if (mesh && mesh.material) {
                            console.log('ðŸŽ¯ Video mesh found, applying consistent color profile');
                            
                            // Create a properly configured video texture
                            const texture = new THREE.VideoTexture(videoEl);
                            
                            // Ensure consistent color space handling across all devices
                            texture.colorSpace = THREE.SRGBColorSpace;
                            texture.minFilter = THREE.LinearFilter;
                            texture.magFilter = THREE.LinearFilter;
                            texture.format = THREE.RGBAFormat;
                            texture.generateMipmaps = false;
                            texture.flipY = false;
                            texture.needsUpdate = true;
                            
                            // Fix texture mapping for proper 360Â° orientation
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                            // Flip the texture horizontally and vertically for proper 360Â° viewing from inside
                            texture.repeat.set(-1, -1);
                            texture.offset.set(1, 1);
                            
                            // Apply to material with consistent settings
                            mesh.material.map = texture;
                            mesh.material.needsUpdate = true;
                            
                            // Ensure material uses sRGB color space
                            if (mesh.material.color) {
                                mesh.material.color.convertSRGBToLinear();
                            }
                            
                            console.log('ðŸŽ¯ Cross-platform color fix and orientation correction applied successfully');
                            
                            // Debug sphere orientation
                            console.log('ðŸŽ¯ Videosphere configuration:', {
                                scale: videosphere.getAttribute('scale'),
                                rotation: videosphere.getAttribute('rotation'),
                                geometry: videosphere.getAttribute('geometry')
                            });
                        } else {
                            console.warn('ðŸŽ¯ Video mesh not found, retrying in 100ms');
                            setTimeout(applyColorFix, 100);
                        }
                    };
                    
                    // Apply when video data is loaded
                    videoEl.addEventListener('loadeddata', applyColorFix);
                    
                    // Also try immediately if video is already loaded
                    if (videoEl.readyState >= 2) {
                        setTimeout(applyColorFix, 50);
                    }
                    
                    // Apply when A-Frame mesh is ready
                    videosphere.addEventListener('materialtextureloaded', applyColorFix);
                }
            }
        });

        class HeadlessViewer360 {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.videosphere = null;
                this.video = null;
                this.hlsPlayer = null;
                this.isReady = false;
                this.isSceneReady = false;
                this.isVideoReady = false;
                this.isPlaying = false;
                this.isMuted = false;
                this.currentTime = 0;
                this.duration = 0;
                this.videoUrl = '';
                this.parentOrigin = '*';
                this.lastHeartbeat = 0;
                this.connectionHealth = true;
                this.pendingPlaybackState = null;
                this.initializationStartTime = performance.now();
                this.autoStart = false;
                this.orientationPermission = 'unknown';
                this.devicePerformance = 'unknown';
                this.networkQuality = 'unknown';
                this.currentFov = 75;
                this.preloadProgress = 0;
                this.isBuffering = false;
                this.lastTimeUpdate = 0;
                this.syncTolerance = 0.1;
                this.lastSyncTime = 0;
                this.syncAttempts = 0;
                this.maxSyncAttempts = 5;
                this.isInSyncGracePeriod = false;
                this.syncGracePeriodStart = 0;
                this.gracePeriodDuration = 2000;
                this.performanceMonitor = {
                    fps: 0,
                    frameCount: 0,
                    lastFrameTime: 0,
                    averageFps: 0,
                    frameDrops: 0
                };
                this.lastPauseTime = 0;
                this.lastPlayTime = 0;
                this.pauseGracePeriod = 3000; // 3 second grace period after pause
                
                this.init();
            }
            
            init() {
                console.log('ðŸŽ¯ Initializing headless 360Â° viewer');
                
                // Detect mobile device early for optimizations
                const isMobile = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|Opera Mini/i.test(navigator.userAgent);
                const isLowEndDevice = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4;
                
                console.log('ðŸ“± Device detection:', { isMobile, isLowEndDevice, cores: navigator.hardwareConcurrency });
                
                // Get URL parameters
                const params = new URLSearchParams(window.location.search);
                this.videoUrl = params.get('video') || '';
                this.parentOrigin = params.get('origin') || '*';
                this.autoStart = params.get('autoStart') === 'true';
                
                // Initialize A-Frame scene with mobile optimizations
                this.scene = document.querySelector('#scene');
                this.camera = document.querySelector('#camera');
                this.videosphere = document.querySelector('#videosphere');
                this.video = document.querySelector('#video-asset');
                
                // Apply mobile-specific video optimizations
                if (isMobile) {
                    console.log('ðŸ“± Applying mobile video optimizations');
                    if (this.video) {
                        // Additional mobile attributes for better compatibility
                        this.video.setAttribute('muted', 'true');
                        this.video.setAttribute('autoplay', 'false'); // Prevent auto-download
                        this.video.setAttribute('controls', 'false');
                        
                        // iOS-specific optimizations
                        if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                            this.video.setAttribute('webkit-playsinline', 'true');
                            this.video.setAttribute('x-webkit-airplay', 'allow');
                        }
                    }
                    
                    // Lower A-Frame renderer quality for mobile
                    if (this.scene) {
                        this.scene.setAttribute('renderer', 'antialias: false; colorManagement: true; outputColorSpace: srgb; physicallyCorrectLights: false');
                        
                        // Reduce shadow quality on mobile
                        this.scene.setAttribute('shadow', 'type: basic');
                    }
                }
                
                this.setupEventListeners();
                this.setupMessageHandling();
                this.startPerformanceMonitoring();
                this.detectDeviceCapabilities();
                this.detectNetworkQuality();
                
                // DON'T automatically request device orientation permission - wait for main app
                // this.requestDeviceOrientationPermission(); // REMOVED
                
                // Auto-preload if specified (with mobile consideration)
                if (this.autoStart && this.videoUrl) {
                    // Delay video loading slightly on mobile to allow scene setup
                    const loadDelay = isMobile ? 200 : 0;
                    setTimeout(() => {
                        this.loadVideo(this.videoUrl);
                    }, loadDelay);
                }
                
                // Send ready message after initialization (faster on mobile)
                const readyDelay = isMobile ? 50 : 100;
                setTimeout(() => {
                    this.sendMessage('ready', {
                        mode: 'headless',
                        autoStart: this.autoStart,
                        orientationPermission: this.orientationPermission,
                        devicePerformance: this.devicePerformance,
                        networkQuality: this.networkQuality,
                        isMobile: isMobile,
                        isLowEndDevice: isLowEndDevice
                    });
                }, readyDelay);
                
                // Expose debug method to parent window
                if (window.parent && window.parent !== window) {
                    window.parent.xrVideoDebug = () => this.getPlaybackDebugInfo();
                }
            }
            
            setupEventListeners() {
                // A-Frame scene events
                this.scene.addEventListener('loaded', () => {
                    console.log('ðŸŽ¯ A-Frame scene loaded');
                    this.isSceneReady = true;
                    this.checkReadyState();
                });
                
                // Video events
                this.video.addEventListener('loadedmetadata', () => {
                    console.log('ðŸŽ¯ Video metadata loaded');
                    this.duration = this.video.duration;
                    this.isVideoReady = true;
                    this.checkReadyState();
                    
                    // Apply any pending playback state
                    if (this.pendingPlaybackState) {
                        this.applyPlaybackState(this.pendingPlaybackState);
                        this.pendingPlaybackState = null;
                    }
                });
                
                this.video.addEventListener('canplaythrough', () => {
                    console.log('ðŸŽ¯ Video can play through');
                    this.sendMessage('preloaded', {
                        duration: this.duration,
                        readyState: this.video.readyState
                    });
                });
                
                this.video.addEventListener('timeupdate', () => {
                    this.currentTime = this.video.currentTime;
                    this.sendMessage('timeupdate', {
                        currentTime: this.currentTime,
                        duration: this.duration
                    });
                });
                
                this.video.addEventListener('play', () => {
                    this.isPlaying = true;
                    console.log('ðŸŽ¯ Video play event fired');
                    this.sendMessage('play');
                });
                
                this.video.addEventListener('pause', () => {
                    this.isPlaying = false;
                    console.log('ðŸŽ¯ Video pause event fired');
                    this.sendMessage('pause');
                });
                
                this.video.addEventListener('volumechange', () => {
                    this.isMuted = this.video.muted;
                    this.sendMessage('mutechange', {
                        muted: this.isMuted,
                        volume: this.video.volume
                    });
                });
                
                this.video.addEventListener('seeking', () => {
                    this.isBuffering = true;
                    this.sendMessage('buffering', { isBuffering: true });
                });
                
                this.video.addEventListener('seeked', () => {
                    this.isBuffering = false;
                    this.sendMessage('buffering', { isBuffering: false });
                });
                
                this.video.addEventListener('error', (e) => {
                    console.error('ðŸŽ¯ Video error:', e);
                    this.showError('Video playback error');
                    this.sendMessage('error', {
                        error: 'Video playback error',
                        code: this.video.error?.code,
                        message: this.video.error?.message
                    });
                });
                
                // Camera FOV changes
                this.camera.addEventListener('componentchanged', (e) => {
                    if (e.detail.name === 'camera') {
                        this.currentFov = this.camera.getAttribute('fov');
                        this.sendMessage('fovchange', {
                            fov: this.currentFov
                        });
                    }
                });
                
                // Window events
                window.addEventListener('beforeunload', () => {
                    this.cleanup();
                });
            }
            
            setupMessageHandling() {
                window.addEventListener('message', (event) => {
                    if (event.data.channel !== 'viewer-360-headless') return;
                    
                    console.log('ðŸŽ¯ Received command:', event.data.type, event.data);
                    
                    this.handleCommand(event.data.type, event.data);
                });
            }
            
            handleCommand(type, data) {
                try {
                    switch (type) {
                        case 'start':
                            this.start();
                            break;
                        case 'playback-state':
                            this.handlePlaybackState(data);
                            break;
                        case 'time-update':
                            this.handleTimeUpdate(data);
                            break;
                        case 'play':
                            this.play();
                            break;
                        case 'pause':
                            this.pause();
                            break;
                        case 'togglePlay':
                            this.togglePlay();
                            break;
                        case 'seek':
                            this.seek(data.value || data.time);
                            break;
                        case 'syncSeek':
                            this.syncSeek(data.time, data.tolerance);
                            break;
                        case 'smoothSeek':
                            this.smoothSeek(data.time, data.tolerance);
                            break;
                        case 'mute':
                            this.setMute(data.value);
                            break;
                        case 'toggleMute':
                            this.toggleMute();
                            break;
                        case 'set-inverse-controls':
                            this.setInverseControls(data);
                            break;
                        case 'setFov':
                            this.setFov(data.value);
                            break;
                        case 'recenter':
                            this.recenter();
                            break;
                        case 'preload':
                            this.preload();
                            break;
                        case 'setVideoSource':
                            this.setVideoSource(data.videoUrl);
                            break;
                        case 'switchChapter':
                            this.switchChapter(data.chapterNumber, data.videoUrl);
                            break;
                        case 'setOrientationPermission':
                            this.setOrientationPermission(data);
                            break;
                        case 'requestOrientationPermission':
                            this.requestDeviceOrientationPermission();
                            break;
                        case 'getConnectionHealth':
                            this.getConnectionHealth();
                            break;
                        case 'heartbeat':
                            this.handleHeartbeat(data.timestamp);
                            break;
                        case 'ping':
                            this.handlePing(data.timestamp);
                            break;
                        case 'getPlaybackDebugInfo':
                            this.sendMessage('playbackdebuginfo', this.getPlaybackDebugInfo());
                            break;
                        default:
                            console.warn('ðŸŽ¯ Unknown command:', type);
                            this.sendMessage('commanderror', {
                                command: type,
                                error: 'Unknown command type'
                            });
                    }
                    
                    // Send success response
                    this.sendMessage('commandresponse', {
                        command: type,
                        success: true
                    });
                    
                } catch (error) {
                    console.error('ðŸŽ¯ Command error:', type, error);
                    this.sendMessage('commanderror', {
                        command: type,
                        error: error.message || 'Command execution failed'
                    });
                }
            }
            
            sendMessage(type, data = {}) {
                const message = {
                    channel: 'viewer-360-headless',
                    type: type,
                    timestamp: performance.now(),
                    ...data
                };
                
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage(message, this.parentOrigin);
                }
            }
            
            start() {
                console.log('ðŸŽ¯ Starting viewer');
                this.sendMessage('started', {
                    orientationPermission: this.orientationPermission,
                    hasDeviceYaw: this.hasDeviceYaw(),
                    mode: 'headless',
                    devicePerformance: this.devicePerformance,
                    networkQuality: this.networkQuality
                });
            }
            
            handlePlaybackState(data) {
                console.log('ðŸŽ¯ Handling playback state:', data);
                
                // Store the playback state for when video is ready
                this.pendingPlaybackState = data;
                
                // If video is ready, apply the state immediately
                if (this.isVideoReady && this.video) {
                    this.applyPlaybackState(data);
                }
            }
            
            applyPlaybackState(data) {
                if (!this.video || !this.isVideoReady) return;
                
                console.log('ðŸŽ¯ Applying playback state:', data);
                
                const now = performance.now();
                
                // Sync the current time if provided
                if (typeof data.currentTime === 'number' && data.currentTime >= 0) {
                    const timeDiff = Math.abs(this.video.currentTime - data.currentTime);
                    if (timeDiff > 0.5) { // Only sync if difference is significant
                        this.video.currentTime = data.currentTime;
                    }
                }
                
                // Apply play/pause state with grace period protection
                if (data.isPlaying && this.video.paused) {
                    // Check if we recently paused - if so, don't auto-play
                    const timeSinceLastPause = now - this.lastPauseTime;
                    if (timeSinceLastPause < this.pauseGracePeriod) {
                        console.log('ðŸŽ¯ Ignoring auto-play request - recent pause detected', { timeSinceLastPause });
                        return;
                    }
                    
                    console.log('ðŸŽ¯ Auto-starting video playback');
                    this.lastPlayTime = now;
                    this.video.play().catch(e => {
                        console.warn('ðŸŽ¯ Auto-play failed:', e);
                        // This is expected in some browsers without user interaction
                    });
                } else if (!data.isPlaying && !this.video.paused) {
                    console.log('ðŸŽ¯ Auto-pausing video playback');
                    this.lastPauseTime = now;
                    this.video.pause();
                }
            }
            
            handleTimeUpdate(data) {
                if (!this.video || !this.isVideoReady) return;
                
                // Only sync time if video is playing - avoid interfering with pause state
                if (!this.video.paused && typeof data.currentTime === 'number' && data.currentTime >= 0) {
                    const timeDiff = Math.abs(this.video.currentTime - data.currentTime);
                    if (timeDiff > 0.2) { // Sync if drift is significant
                        console.log('ðŸŽ¯ Syncing video time:', { 
                            videoTime: this.video.currentTime, 
                            parentTime: data.currentTime,
                            drift: timeDiff
                        });
                        this.video.currentTime = data.currentTime;
                    }
                }
            }
            
            play() {
                if (this.video && this.isVideoReady) {
                    this.lastPlayTime = performance.now();
                    this.video.play().catch(e => {
                        console.error('ðŸŽ¯ Play failed:', e);
                        this.sendMessage('error', { error: 'Play failed: ' + e.message });
                    });
                }
            }
            
            pause() {
                if (this.video && this.isVideoReady) {
                    this.lastPauseTime = performance.now();
                    this.video.pause();
                }
            }
            
            togglePlay() {
                if (this.isPlaying) {
                    this.pause();
                } else {
                    this.play();
                }
            }
            
            seek(time) {
                if (this.video && this.isVideoReady && time >= 0 && time <= this.duration) {
                    this.video.currentTime = time;
                    this.currentTime = time;
                }
            }
            
            syncSeek(time, tolerance = 0.1) {
                if (!this.video || !this.isVideoReady) return;
                
                const currentTime = this.video.currentTime;
                const drift = Math.abs(time - currentTime);
                
                if (drift > tolerance) {
                    console.log('ðŸŽ¯ Sync seek:', { from: currentTime, to: time, drift });
                    this.startSyncGracePeriod();
                    this.video.currentTime = time;
                }
            }
            
            smoothSeek(time, tolerance = 0.1) {
                if (!this.video || !this.isVideoReady) return;
                
                const currentTime = this.video.currentTime;
                const drift = time - currentTime;
                
                if (Math.abs(drift) > tolerance) {
                    const maxStep = 0.2;
                    const step = Math.sign(drift) * Math.min(Math.abs(drift), maxStep);
                    this.video.currentTime = currentTime + step;
                    
                    // Continue smooth seeking if needed
                    if (Math.abs(drift) > maxStep) {
                        setTimeout(() => {
                            this.smoothSeek(time, tolerance);
                        }, 50);
                    }
                }
            }
            
            setMute(muted) {
                if (this.video) {
                    this.video.muted = muted;
                }
            }
            
            toggleMute() {
                if (this.video) {
                    this.video.muted = !this.video.muted;
                }
            }
            
            setFov(fov) {
                if (this.camera && fov >= 75 && fov <= 120) {
                    this.camera.setAttribute('fov', fov);
                    this.currentFov = fov;
                }
            }
            
            setInverseControls(options) {
                if (this.camera) {
                    const lookControls = this.camera.getAttribute('look-controls');
                    const newControls = {
                        ...lookControls,
                        reverseMouseDrag: options.inverseX || false,
                        // Always reverse touch drag for mobile devices to match expected behavior
                        reverseTouchDrag: true
                    };
                    
                    this.camera.setAttribute('look-controls', newControls);
                    console.log('ðŸŽ¯ Inverse controls set:', newControls);
                    
                    this.sendMessage('commandresponse', {
                        command: 'set-inverse-controls',
                        success: true,
                        inverseX: options.inverseX
                    });
                }
            }
            
            recenter() {
                console.log('ðŸŽ¯ Recenter called - resetting camera rotation with -90Â° offset');
                
                if (this.camera) {
                    // Reset camera rotation to -90Â° offset (90Â° counter-clockwise from default)
                    this.camera.setAttribute('rotation', '0 -90 0');
                    
                    // Also reset any accumulated rotation from look controls
                    const lookControls = this.camera.components['look-controls'];
                    if (lookControls) {
                        lookControls.pitchObject.rotation.x = 0;
                        lookControls.yawObject.rotation.y = 0;
                        console.log('ðŸŽ¯ Reset look controls rotation with -90Â° offset');
                    }
                    
                    // Send success message back to parent
                    this.sendMessage('recenter', { 
                        success: true, 
                        timestamp: performance.now(),
                        rotation: { x: 0, y: -90, z: 0 }
                    });
                    
                    console.log('ðŸŽ¯ Camera recentered successfully with -90Â° offset');
                } else {
                    console.error('ðŸŽ¯ Cannot recenter - camera not found');
                    this.sendMessage('recenter', { 
                        success: false, 
                        error: 'Camera not found',
                        timestamp: performance.now()
                    });
                }
            }
            
            preload() {
                if (this.video && this.videoUrl) {
                    this.video.load();
                }
            }
            
            setVideoSource(videoUrl) {
                console.log('ðŸŽ¯ setVideoSource called with:', videoUrl);
                
                // Clean up any existing HLS player
                if (this.hlsPlayer) {
                    console.log('ðŸŽ¯ Cleaning up existing HLS player');
                    this.hlsPlayer.destroy();
                    this.hlsPlayer = null;
                }
                
                // Reset video element
                if (this.video) {
                    this.video.pause();
                    this.video.removeAttribute('src');
                    this.video.load();
                }
                
                this.videoUrl = videoUrl;
                this.isVideoReady = false;
                
                // Clear any pending playback state since we're loading a new video
                this.pendingPlaybackState = null;
                
                if (videoUrl) {
                    this.loadVideo(videoUrl);
                } else {
                    console.warn('ðŸŽ¯ No video URL provided to setVideoSource');
                }
            }
            
            switchChapter(chapterNumber, videoUrl) {
                console.log('ðŸŽ¯ Switching to chapter:', chapterNumber, videoUrl);
                this.setVideoSource(videoUrl);
            }
            
            setOrientationPermission(permissionData) {
                console.log('ðŸŽ¯ Setting orientation permission from main app:', permissionData);
                
                // Update local permission state
                this.orientationPermission = permissionData.granted ? 'granted' : 'denied';
                
                // Send confirmation back to main app
                this.sendMessage('orientationpermission', {
                    granted: permissionData.granted,
                    requested: permissionData.requested,
                    supported: permissionData.supported,
                    error: permissionData.error,
                    source: 'main-app'
                });
                
                // Update A-Frame scene if needed
                if (this.camera && permissionData.granted) {
                    // Enable device orientation controls if permission granted
                    this.camera.setAttribute('look-controls', 'enabled: true; pointerLockEnabled: false; magicWindowTrackingEnabled: true; reverseMouseDrag: true; reverseTouchDrag: true');
                }
            }
            
            loadVideo(url) {
                console.log('ðŸŽ¯ Loading video:', url);
                this.showLoading();
                
                // Validate URL
                if (!url || typeof url !== 'string') {
                    this.showError('Invalid video URL provided', { url });
                    return;
                }
                
                // Increase timeout and add retry logic
                let loadingTimeout;
                let retryCount = 0;
                const maxRetries = 3;
                const timeoutDuration = 60000; // Increase to 60 seconds
                
                const attemptLoad = () => {
                    retryCount++;
                    console.log(`ðŸŽ¯ Loading attempt ${retryCount}/${maxRetries + 1} for:`, url);
                    
                    // Clear any existing timeout
                    if (loadingTimeout) {
                        clearTimeout(loadingTimeout);
                    }
                    
                    // Set loading timeout
                    loadingTimeout = setTimeout(() => {
                        console.error('ðŸŽ¯ Video loading timeout, attempt:', retryCount);
                        
                        if (retryCount <= maxRetries) {
                            console.log('ðŸŽ¯ Retrying video load...');
                            // Reset video element before retry
                            if (this.video) {
                                this.video.pause();
                                this.video.removeAttribute('src');
                                this.video.load();
                            }
                            
                            // Wait a bit before retry
                            setTimeout(attemptLoad, 2000);
                        } else {
                            this.showError('Video loading failed after multiple attempts - please check your connection', { 
                                url, 
                                attempts: retryCount,
                                timeout: timeoutDuration 
                            });
                        }
                    }, timeoutDuration);
                    
                    // Clear timeout when video loads
                    const clearLoadingTimeout = () => {
                        if (loadingTimeout) {
                            clearTimeout(loadingTimeout);
                            loadingTimeout = null;
                        }
                    };
                    
                    try {
                        if (url.includes('.m3u8')) {
                            this.loadHLSVideo(url, clearLoadingTimeout);
                        } else {
                            this.loadDirectVideo(url, clearLoadingTimeout);
                        }
                    } catch (error) {
                        clearLoadingTimeout();
                        console.error('ðŸŽ¯ Error loading video:', error);
                        
                        if (retryCount <= maxRetries) {
                            console.log('ðŸŽ¯ Retrying after error...');
                            setTimeout(attemptLoad, 2000);
                        } else {
                            this.showError('Failed to load video after multiple attempts', { 
                                url, 
                                error: error.message, 
                                attempts: retryCount 
                            });
                        }
                    }
                };
                
                // Start the first attempt
                attemptLoad();
            }
            
            loadHLSVideo(url, clearLoadingTimeout) {
                console.log('ðŸŽ¯ Loading HLS video:', url);
                
                if (Hls.isSupported()) {
                    this.hlsPlayer = new Hls({
                        enableWorker: false, // Disable worker for better mobile compatibility
                        lowLatencyMode: false,
                        backBufferLength: 90
                    });
                    
                    this.hlsPlayer.loadSource(url);
                    this.hlsPlayer.attachMedia(this.video);
                    
                    this.hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
                        console.log('ðŸŽ¯ HLS manifest parsed');
                        clearLoadingTimeout();
                        
                        // Ensure videosphere is updated with new source
                        if (this.videosphere) {
                            this.videosphere.setAttribute('src', '#video-asset');
                            console.log('ðŸŽ¯ Updated videosphere source for HLS');
                        }
                        
                        this.hideLoading();
                    });
                    
                    this.hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
                        console.error('ðŸŽ¯ HLS error:', data);
                        
                        // Handle recoverable errors
                        if (data.fatal) {
                            clearLoadingTimeout();
                            
                            switch (data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    console.log('ðŸŽ¯ Network error, attempting recovery...');
                                    this.hlsPlayer.startLoad();
                                    break;
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    console.log('ðŸŽ¯ Media error, attempting recovery...');
                                    this.hlsPlayer.recoverMediaError();
                                    break;
                                default:
                                    console.log('ðŸŽ¯ Fatal error, destroying HLS player');
                                    this.hlsPlayer.destroy();
                                    this.showError('HLS streaming error - video may not be available', { 
                                        url, 
                                        errorType: data.type, 
                                        errorDetails: data.details,
                                        fatal: data.fatal
                                    });
                                    break;
                            }
                        } else {
                            console.warn('ðŸŽ¯ Non-fatal HLS error:', data);
                        }
                    });
                    
                } else if (this.video.canPlayType('application/vnd.apple.mpegurl')) {
                    console.log('ðŸŽ¯ Using native HLS support');
                    this.video.src = url;
                    
                    // Ensure videosphere is updated with new source
                    if (this.videosphere) {
                        this.videosphere.setAttribute('src', '#video-asset');
                        console.log('ðŸŽ¯ Updated videosphere source for native HLS');
                    }
                    
                    clearLoadingTimeout();
                    this.hideLoading();
                } else {
                    clearLoadingTimeout();
                    this.showError('HLS not supported on this device', { url });
                }
            }
            
            loadDirectVideo(url, clearLoadingTimeout) {
                console.log('ðŸŽ¯ Loading direct video:', url);
                
                // Enhanced mobile detection for adaptive loading
                const isMobile = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|Opera Mini/i.test(navigator.userAgent);
                const isSlowConnection = this.networkQuality === 'low' || this.networkQuality === 'medium';
                
                // Reset any previous error handlers
                this.video.onerror = null;
                this.video.onloadedmetadata = null;
                this.video.oncanplaythrough = null;
                this.video.onstalled = null;
                this.video.onsuspend = null;
                this.video.onprogress = null;
                this.video.onwaiting = null;
                
                // Enhanced error handling with recovery strategies
                this.video.onerror = (error) => {
                    console.error('ðŸŽ¯ Direct video loading error:', error);
                    clearLoadingTimeout();
                    
                    const errorCode = this.video.error ? this.video.error.code : 'unknown';
                    const errorMessage = this.video.error ? this.video.error.message : 'Video load failed';
                    
                    // Try different recovery strategies based on error type
                    if (this.video.error && this.video.error.code === MediaError.MEDIA_ERR_NETWORK) {
                        console.log('ðŸŽ¯ Network error detected - will retry with different strategy');
                        this.sendMessage('error', {
                            error: 'Network error loading video - retrying...',
                            details: { url, errorCode, errorMessage, retryable: true },
                            recoverable: true
                        });
                    } else if (this.video.error && this.video.error.code === MediaError.MEDIA_ERR_DECODE) {
                        console.log('ðŸŽ¯ Decode error detected - video format may not be supported');
                        this.sendMessage('error', {
                            error: 'Video format not supported on this device',
                            details: { url, errorCode, errorMessage, retryable: false },
                            recoverable: false
                        });
                    } else {
                        this.showError('Failed to load video file', { 
                            url, 
                            errorCode, 
                            errorMessage,
                            networkState: this.video.networkState,
                            readyState: this.video.readyState
                        });
                    }
                };
                
                // Handle successful metadata load with enhanced feedback
                this.video.onloadedmetadata = () => {
                    console.log('ðŸŽ¯ Direct video metadata loaded');
                    clearLoadingTimeout();
                    
                    // Send metadata loaded message
                    this.sendMessage('loadedmetadata', {
                        duration: this.video.duration,
                        videoWidth: this.video.videoWidth,
                        videoHeight: this.video.videoHeight,
                        readyState: this.video.readyState
                    });
                    
                    // Ensure videosphere is updated with new source
                    if (this.videosphere) {
                        this.videosphere.setAttribute('src', '#video-asset');
                        console.log('ðŸŽ¯ Updated videosphere source');
                    }
                    
                    this.hideLoading();
                };
                
                // Enhanced network monitoring
                this.video.onstalled = () => {
                    console.warn('ðŸŽ¯ Video loading stalled - network may be slow');
                    this.sendMessage('buffering', { 
                        isBuffering: true, 
                        reason: 'stalled',
                        networkState: this.video.networkState 
                    });
                };
                
                this.video.onsuspend = () => {
                    console.warn('ðŸŽ¯ Video loading suspended by browser');
                    this.sendMessage('buffering', { 
                        isBuffering: true, 
                        reason: 'suspended',
                        networkState: this.video.networkState 
                    });
                };
                
                // Progress monitoring for mobile devices
                this.video.onprogress = () => {
                    if (isMobile && this.video.buffered.length > 0) {
                        const buffered = this.video.buffered.end(this.video.buffered.length - 1);
                        const duration = this.video.duration || 1;
                        const percentage = Math.round((buffered / duration) * 100);
                        
                        if (percentage % 10 === 0) { // Log every 10% on mobile
                            console.log(`ðŸ“± Video buffered: ${percentage}% (${buffered.toFixed(1)}s / ${duration.toFixed(1)}s)`);
                        }
                    }
                };
                
                // Handle waiting state (buffering)
                this.video.onwaiting = () => {
                    console.log('ðŸŽ¯ Video waiting for data');
                    this.sendMessage('buffering', { 
                        isBuffering: true, 
                        reason: 'waiting',
                        currentTime: this.video.currentTime 
                    });
                };
                
                // Handle when enough data is available to play
                this.video.oncanplaythrough = () => {
                    console.log('ðŸŽ¯ Video can play through');
                    this.sendMessage('canplaythrough', {
                        readyState: this.video.readyState,
                        networkState: this.video.networkState
                    });
                    this.hideLoading();
                };
                
                // Adaptive loading strategy based on device and connection
                if (isMobile && isSlowConnection) {
                    console.log('ðŸ“± Mobile + slow connection detected - using conservative loading');
                    this.video.preload = 'metadata';
                } else {
                    this.video.preload = 'auto';
                }
                
                // Set source and start loading with enhanced error recovery
                try {
                    this.video.src = url;
                    this.video.load();
                    
                    console.log(`ðŸŽ¯ Started loading video: ${url} (Mobile: ${isMobile}, Slow: ${isSlowConnection})`);
                } catch (loadError) {
                    console.error('ðŸŽ¯ Error setting video source:', loadError);
                    clearLoadingTimeout();
                    this.showError('Failed to set video source', { 
                        url, 
                        error: loadError.message 
                    });
                    return;
                }
                
                // Enhanced backup timeout with retry logic
                setTimeout(() => {
                    if (!this.isVideoReady && this.video.readyState < 1) {
                        console.warn('ðŸŽ¯ Video metadata still not loaded after 10 seconds');
                        
                        // Force a reload attempt
                        console.log('ðŸŽ¯ Attempting forced video reload');
                                                 try {
                             this.video.load();
                         } catch (reloadError) {
                             console.error('ðŸŽ¯ Forced reload failed:', reloadError);
                         }
                    }
                }, 10000);
            }
            
            startPerformanceMonitoring() {
                const monitorFrame = () => {
                    const now = performance.now();
                    this.performanceMonitor.frameCount++;
                    
                    if (this.performanceMonitor.lastFrameTime > 0) {
                        const frameTime = now - this.performanceMonitor.lastFrameTime;
                        this.performanceMonitor.fps = 1000 / frameTime;
                        
                        // Update average FPS
                        if (this.performanceMonitor.frameCount > 10) {
                            this.performanceMonitor.averageFps = 
                                (this.performanceMonitor.averageFps * 0.9) + 
                                (this.performanceMonitor.fps * 0.1);
                        }
                        
                        // Detect frame drops
                        if (this.performanceMonitor.fps < 25) {
                            this.performanceMonitor.frameDrops++;
                        }
                        
                        // Send FPS updates occasionally
                        if (this.performanceMonitor.frameCount % 60 === 0) {
                            this.sendMessage('fpsupdate', {
                                fps: this.performanceMonitor.averageFps,
                                frameDrops: this.performanceMonitor.frameDrops
                            });
                        }
                    }
                    
                    this.performanceMonitor.lastFrameTime = now;
                    
                    if (this.isReady) {
                        requestAnimationFrame(monitorFrame);
                    }
                };
                
                requestAnimationFrame(monitorFrame);
            }
            
            detectDeviceCapabilities() {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                if (gl) {
                    const renderer = gl.getParameter(gl.RENDERER);
                    const vendor = gl.getParameter(gl.VENDOR);
                    
                    // Simple performance categorization
                    if (renderer.includes('Mali') || renderer.includes('Adreno 3')) {
                        this.devicePerformance = 'low';
                    } else if (renderer.includes('Adreno 5') || renderer.includes('PowerVR')) {
                        this.devicePerformance = 'medium';
                    } else {
                        this.devicePerformance = 'high';
                    }
                } else {
                    this.devicePerformance = 'low';
                }
                
                this.sendMessage('devicebenchmark', {
                    category: this.devicePerformance,
                    userAgent: navigator.userAgent
                });
            }
            
            detectNetworkQuality() {
                if ('connection' in navigator) {
                    const connection = navigator.connection;
                    const effectiveType = connection.effectiveType;
                    
                    if (effectiveType === '4g') {
                        this.networkQuality = 'high';
                    } else if (effectiveType === '3g') {
                        this.networkQuality = 'medium';
                    } else {
                        this.networkQuality = 'low';
                    }
                } else {
                    this.networkQuality = 'unknown';
                }
                
                this.sendMessage('networkdetected', {
                    quality: this.networkQuality
                });
            }
            
            async requestDeviceOrientationPermission() {
                // This method is now only called if the main app hasn't set permission
                console.log('ðŸŽ¯ Viewer requesting orientation permission - notifying main app');
                
                // Notify main app that we would like permission
                this.sendMessage('orientationrequested', {
                    reason: 'viewer-needs-permission',
                    timestamp: performance.now()
                });
                
                // Keep the fallback logic for non-iOS devices
                if (typeof DeviceOrientationEvent !== 'undefined' && 
                    typeof DeviceOrientationEvent.requestPermission === 'function') {
                    
                    console.log('ðŸŽ¯ iOS device detected - waiting for main app permission');
                    // Don't request directly - wait for main app
                    this.orientationPermission = 'pending';
                } else {
                    // For non-iOS devices, assume granted
                    this.orientationPermission = 'granted';
                    this.sendMessage('orientationpermission', {
                        granted: true,
                        permission: 'granted',
                        source: 'auto-granted'
                    });
                }
            }
            
            hasDeviceYaw() {
                return 'DeviceOrientationEvent' in window;
            }
            
            startSyncGracePeriod() {
                this.isInSyncGracePeriod = true;
                this.syncGracePeriodStart = performance.now();
                
                setTimeout(() => {
                    this.isInSyncGracePeriod = false;
                }, this.gracePeriodDuration);
            }
            
            handleHeartbeat(timestamp) {
                this.lastHeartbeat = timestamp;
                this.connectionHealth = true;
                
                this.sendMessage('heartbeat-response', {
                    timestamp: performance.now(),
                    clientTimestamp: timestamp
                });
            }
            
            handlePing(timestamp) {
                console.log('ðŸŽ¯ Ping received, sending pong response');
                this.sendMessage('pong', {
                    timestamp: performance.now(),
                    clientTimestamp: timestamp,
                    isReady: this.isReady,
                    isSceneReady: this.isSceneReady,
                    isVideoReady: this.isVideoReady,
                    connectionHealth: this.connectionHealth
                });
            }
            
            getConnectionHealth() {
                const now = performance.now();
                const timeSinceLastHeartbeat = now - this.lastHeartbeat;
                const isHealthy = timeSinceLastHeartbeat < 10000; // 10 seconds
                
                this.sendMessage('connectionhealthresponse', {
                    healthy: isHealthy,
                    lastHeartbeat: this.lastHeartbeat,
                    timeSinceLastHeartbeat: timeSinceLastHeartbeat,
                    performanceMonitor: this.performanceMonitor
                });
            }
            
            getPlaybackDebugInfo() {
                const now = performance.now();
                return {
                    isPlaying: this.isPlaying,
                    videoPaused: this.video ? this.video.paused : 'no video',
                    videoCurrentTime: this.video ? this.video.currentTime : 'no video',
                    lastPauseTime: this.lastPauseTime,
                    lastPlayTime: this.lastPlayTime,
                    timeSinceLastPause: now - this.lastPauseTime,
                    timeSinceLastPlay: now - this.lastPlayTime,
                    pauseGracePeriod: this.pauseGracePeriod,
                    isInGracePeriod: (now - this.lastPauseTime) < this.pauseGracePeriod
                };
            }
            
            checkReadyState() {
                if (this.isSceneReady && !this.isReady) {
                    this.isReady = true;
                    console.log('ðŸŽ¯ Viewer ready');
                    this.hideLoading();
                    
                    // Start performance monitoring
                    this.startPerformanceMonitoring();
                }
            }
            
            showLoading() {
                const overlay = document.getElementById('loading-overlay');
                if (overlay) {
                    overlay.classList.add('show');
                    overlay.classList.remove('hidden');
                }
            }
            
            hideLoading() {
                const overlay = document.getElementById('loading-overlay');
                if (overlay) {
                    overlay.classList.remove('show');
                    overlay.classList.add('hidden');
                }
            }
            
            showError(message, details = null) {
                const overlay = document.getElementById('error-overlay');
                const messageEl = document.getElementById('error-message');
                
                if (overlay && messageEl) {
                    messageEl.textContent = message;
                    overlay.style.display = 'flex';
                }
                
                this.hideLoading();
                
                // Send error to parent for handling
                this.sendMessage('error', {
                    error: message,
                    details: details,
                    timestamp: performance.now(),
                    recoverable: true
                });
                
                // Auto-hide error after 5 seconds for non-critical errors
                if (!message.includes('failed') && !message.includes('error')) {
                    setTimeout(() => {
                        this.hideError();
                    }, 5000);
                }
            }
            
            hideError() {
                const overlay = document.getElementById('error-overlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
            }
            
            cleanup() {
                if (this.hlsPlayer) {
                    this.hlsPlayer.destroy();
                }
                
                if (this.video) {
                    this.video.pause();
                    this.video.src = '';
                    this.video.load();
                }
                
                this.sendMessage('cleanup-complete');
            }
        }
        
        // Initialize the viewer when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            new HeadlessViewer360();
        });
    </script>
</body>
</html> 